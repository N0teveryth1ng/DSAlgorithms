TRACKING MY PROGRESS - - -


1. ARRAYS - 
    - easy - (2 left - union find, longest subarray)
    - mid - (1 more left - prefix sum)
    - hard - ( 2 is not done) 



 - - - - - - Points To Focus - - - - - - -
  Recursion, Pointers, greedy, binary search, DP,  


2. BINARY SEARCH -
    - easy 
    - medium 
    - hard

3. Strings - 
    - Basic
    - Medium 
     [ Check the star marked Q's for further clarifics ]  - -


4.  Linked Lists - 
    - singly LL ()
    - Doubly LL 

    (-) At step 6 of LinkedList in striver's DSA sheet - LEC 4,5 Q's are not yet clear to me so keep the practice on 
      


    DLL - - - -  
    - - - insert head - - - 
      
      next_node.next = self.head
      self.head.prev = new_node
      self.head = new_node

    
     - - - insert tail - - -

     if not self.head:
        self.head = new_node
        return

     temp = self.head
     while temp.next:
         temp = temp.next

     temp.next = new_node
     new_node.prev = temp

     
     - - - insert Kth - - - 
     
     if k == 1:
        new_node.next = self.head
        self.head.prev = new_node
        self.head = new_node
        return

     temp = self.hard
     count = 1
     while temp and count < k-1:
        temp = temp.next
        count += 1

     if not temp:
        return

     new_node.next = temp.next
     temp.next = new_node 
     if temp.next:
        temp.next.prev = new_node



    - - -  delete kth - - - 

    if not self.head:
        return

    if k == 1:
       self.delete_tail(val)
       return

    temp = self.head
    count = 1
    while temp and count < k-1:
        temp = temp.next
        count += 1

    if not temp:
       return

   
    if temp.prev:
       temp.prev.next = temp.next 
    if temp.next:
       temp.next.prev = temp.prev  


     
     - - - - delete head - - - - 

     if not self.head:
         return

     self.head = self.head.next
     if self.head.next:
        self.head.prev = None
        return


     - - - - delete tail - - - -

     if not self.head:
         return

     temp = self.head
     while temp.next:
         temp = temp.next

     if temp.prev:
        temp.prev.next = None
     else:
        self.head = None

        

    - Arrays to DLL





5.  Recursions ( break the problem into sub problems and run the same fucntion again )
    - lec - 1 was good but need more strong hold in Recursion
    - lec - 2 is finshed but has to be looking more often (all are same)
    - lec - 3 


6. LL

7. Recursion

8. Bit manipulation - - - 

9.  STACK - always uses a top pointer and insert vals from one way by increasing ---->
    and deletes based by decrementing the top pointer <----- 

    QUEUE - data can be inserted using one way = by start/front pointer and incrementing it 
            same it can be deleted using end/rear pointer by incrementing it

    ATTENTION this may come - 1. infix to prefix
                              2. infix to postfix
                              3. sum of subarray minimum LC - 907

    


    - - - LRU is just another hell i hope i dont get asked in the interview. concept is cleared yet hard to implement
     - - -  and LFU is 10x more worse   



10. sliding window problems - done

11. Heaps - done

12. greedy - 












- - - - - - PROJECTS  - - - - -

- palm payment using cam  
- 